####################################################
# DVrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import json
from packet import Packet

class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.distance = {self.addr: 0}
        self.forwarding_table = {} 
        self.neighbors = {}      

    def broadcast_update(self):
        """Send current distance vector to all neighbors."""
        for port in list(self.links):
            poisoned_distance = {}
            for dest, cost in self.distance.items():
                if dest in self.forwarding_table and self.forwarding_table[dest] == port:
                    poisoned_distance[dest] = float("inf")
                else:
                    poisoned_distance[dest] = cost
            content = json.dumps(poisoned_distance)
            packet = Packet(Packet.ROUTING, self.addr, None, content)
            self.send(port, packet)

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr
            if dst != self.addr and dst in self.forwarding_table:
                self.send(self.forwarding_table[dst], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            _, neighbor_cost = self.neighbors[port]
            neighbor_dv = json.loads(packet.content)
            updated = False
            for dest, cost_to_dest in neighbor_dv.items():
                if dest == self.addr or not isinstance(cost_to_dest, (int, float)) or cost_to_dest < 0:
                    continue
                new_cost = neighbor_cost + cost_to_dest
                old_cost = self.distance.get(dest, float("inf"))
                current_port = self.forwarding_table.get(dest)
                if cost_to_dest == float("inf"):
                    if current_port == port and self.distance.get(dest, float("inf")) != float("inf"):
                        self.distance[dest] = float("inf")
                        del self.forwarding_table[dest]
                        updated = True
                else:
                    if (new_cost < old_cost) or (new_cost == old_cost and current_port is not None and port < current_port):
                        self.distance[dest] = new_cost
                        self.forwarding_table[dest] = port
                        updated = True
            if updated:
                self.broadcast_update()

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        self.neighbors[port] = (endpoint, cost)
        changed = False
        if endpoint not in self.distance or cost < self.distance[endpoint]:
            self.distance[endpoint] = cost
            self.forwarding_table[endpoint] = port
            changed = True
        if changed:
            self.broadcast_update()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        if port in self.neighbors:
            endpoint, _ = self.neighbors.pop(port)
            changed = False
            to_remove = [dest for dest, p in self.forwarding_table.items() if p == port]
            for dest in to_remove:
                del self.forwarding_table[dest]
                self.distance[dest] = float("inf")
                changed = True
            if changed:
                self.broadcast_update()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            self.broadcast_update()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"DVrouter(addr={self.addr})"