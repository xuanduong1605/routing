####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import json
import heapq
from packet import Packet

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        print(f"[DEBUG] LSrouter.__init__ called for {addr}")
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.seq_num = 0
        self.adj = {}              
        self.lsdb = {self.addr: (self.seq_num, dict(self.adj))}
        self.forwarding = {} 
        self.port2nbr = {}

    def _flood_lsa(self):
        self.seq_num += 1
        self.lsdb[self.addr] = (self.seq_num, dict(self.adj))
        self.compute_forwarding_table()
        lsa = {
            "origin": self.addr,
            "seq":    self.seq_num,
            "links":  dict(self.adj)
        }
        pkt = Packet(Packet.ROUTING, self.addr, None, content=json.dumps(lsa))
        for port in self.links:
            self.send(port, pkt.copy())

    def compute_forwarding_table(self):
        graph = { node: links for node, (_, links) in self.lsdb.items() }
        dist = {n: float("inf") for n in graph}
        prev = {}
        dist[self.addr] = 0
        heap = [(0, self.addr)]
        while heap:
            d, u = heapq.heappop(heap)
            if d > dist[u]:
                continue
            for v, cost in graph[u].items():
                nd = d + cost
                if nd < dist.get(v, float("inf")):
                    dist[v] = nd
                    prev[v] = u
                    heapq.heappush(heap, (nd, v))

        self.forwarding.clear()
        for dest in graph:
            if dest == self.addr or dest not in prev:
                continue
            hop = dest
            while prev[hop] != self.addr:
                hop = prev[hop]
            self.forwarding[dest] = hop

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            dst = packet.dst_addr
            next_hop = self.forwarding.get(dst)
            if next_hop is None:
                return
            for p in self.links:
                if self.port2nbr[p] == next_hop:
                    self.send(p, packet)
                    return
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            lsa = json.loads(packet.content)
            origin, seq, nbrs = lsa["origin"], lsa["seq"], lsa["links"]

            seen_seq, _ = self.lsdb.get(origin, (-1, None))
            if seq <= seen_seq:
                return

            self.lsdb[origin] = (seq, nbrs)

            self.compute_forwarding_table()

            for p in self.links:
                if p == port:
                    continue
                self.send(p, packet.copy())

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.port2nbr[port] = endpoint
        self.adj[endpoint] = cost
        self._flood_lsa()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        nbr = self.port2nbr.pop(port, None)
        if nbr is not None:
            self.adj.pop(nbr, None)
            self._flood_lsa()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self._flood_lsa()

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
